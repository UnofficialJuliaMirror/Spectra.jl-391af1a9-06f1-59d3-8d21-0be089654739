<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Pre-Processing · Spectra documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Spectra documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="GeneralFunctions.html">General Functions</a></li><li><a class="toctext" href="Installation.html">Installation</a></li><li><a class="toctext" href="MachineLearning.html">Machine Learning</a></li><li><a class="toctext" href="PeakFitting.html">Peak fitting</a></li><li class="current"><a class="toctext" href="PreProcessing.html">Pre-Processing</a><ul class="internal"><li><a class="toctext" href="#Temperature-and-frequency-corrections-for-Raman-spectra-1">Temperature and frequency corrections for Raman spectra</a></li><li><a class="toctext" href="#Smoothing-signals-1">Smoothing signals</a></li><li><a class="toctext" href="#Baseline-subtraction-1">Baseline subtraction</a></li><li><a class="toctext" href="#Frequency-shifts-correction-1">Frequency shifts correction</a></li><li><a class="toctext" href="#array-manipulation-1">array manipulation</a></li></ul></li><li><a class="toctext" href="References.html">References</a></li><li><a class="toctext" href="Tips.html">Tips</a></li><li><a class="toctext" href="index.html">Welcome to Spectra&#39;s documentation!</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="PreProcessing.html">Pre-Processing</a></li></ul><a class="edit-page" href="https://github.com/charlesll/Spectra.jl/blob/master/docs/src/PreProcessing.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Pre-Processing</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Pre-Processing-1" href="#Pre-Processing-1">Pre-Processing</a></h1><h2><a class="nav-anchor" id="Temperature-and-frequency-corrections-for-Raman-spectra-1" href="#Temperature-and-frequency-corrections-for-Raman-spectra-1">Temperature and frequency corrections for Raman spectra</a></h2><p>Raman spectra can be corrected from temperature and excitation line effects using this function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Spectra.tlcorrection" href="#Spectra.tlcorrection"><code>Spectra.tlcorrection</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">tlcorrection(data::Array{Float64},temp::Float64,wave::Float64;correction=&quot;long&quot;,normalisation=&quot;area&quot;,density=2210.0)</code></pre><p><strong>Inputs</strong></p><pre><code class="language-none">data: Array{Float64}
	input spectrum with x and y in first and second columns respectively
temp: Float64
	temperature in °C
wave: Float64
	wavenumber at which the spectrum was acquirred in nm</code></pre><p><strong>Options</strong></p><pre><code class="language-none">correction: String
	equation used for the correction. Choose between &quot;long&quot;, &quot;galeener&quot;, or &quot;hehlen&quot;. Default = &quot;long&quot;.
normalisation: String
	indicate if you want to normalise your signal or not. Choose between &quot;intensity&quot;, &quot;area&quot;, or &quot;no&quot;. Default = &quot;area&quot;.
density: Float64
	density of the studied material in kg m-3, to be used with the &quot;hehlen&quot; equation. Default = 2210.0 (density of silica).</code></pre><p><strong>Outputs</strong></p><pre><code class="language-none">x: Array{Float64}
	x values
long: Array{Float64}
	corrected y values
eselong: Array{Float64}
	errors calculated as sqrt(y) on raw data and propagated after the correction.</code></pre><p><strong>Notes</strong></p><p>This correction uses the formula reported in Galeener and Sen (1978), Mysen et al. (1982), Brooker et al. (1988) and Hehlen et al. (2010).</p><p>The &quot;galeener&quot; equation is the exact one reported in Galeener and Sen (1978), which is a modification from Shuker and Gammon (1970) for accounting of (vo - v)^4 dependence of the Raman intensity. See also Brooker et al. (1988) for further discussion.</p><p>The &quot;long&quot; equation is that of Galeener and Sen (1978) corrected by a vo^3 coefficient for removing the cubic meter dimension of the equation of &quot;galeener&quot;. This equation has been used in Mysen et al. (1982), Neuville and Mysen (1996) and Le Losq et al. (2012).</p><p>The &quot;hehlen&quot; equation is that reported in Hehlen et al. (2010). It actually originates before this publication (Brooker et al. 1988). It uses a different correction that avoid crushing the signal below 500 cm-1. THerefore, it has the advantage of keeping intact the Boson peak signal in glasses.</p></div></div><a class="source-link" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/aa369ae314ee3b94b1fb11d1513243ef035d0da2/src/tlcorrection.jl#L14-L55">source</a></section><h2><a class="nav-anchor" id="Smoothing-signals-1" href="#Smoothing-signals-1">Smoothing signals</a></h2><p>Smoothing the signal is achieved with the smooth function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Spectra.smooth" href="#Spectra.smooth"><code>Spectra.smooth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">smooth(x,y;method=&quot;whittaker&quot;, window_length=5, polyorder = 2, Lambda = 10.0.^5, d=2, ese_y=1.0)</code></pre><p>smooth the provided y signal (sampled on x)</p><p><strong>Inputs</strong></p><pre><code class="language-none">x: vector
	Nx1 array of x values (equally spaced).
y: vector
	Nx1 array of y values (equally spaced).
method: str
	Method for smoothing the signal;
	choose between savgol (Savitzky-Golay), GCVSmoothedNSpline, MSESmoothedNSpline, DOFSmoothedNSpline, whittaker, &#39;flat&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;bartlett&#39;, &#39;blackman&#39;.</code></pre><p><strong>Options</strong></p><pre><code class="language-none">window_length: int
	The length of the filter window (i.e. the number of coefficients). window_length must be a positive odd integer.
polyorder: int
	The order of the polynomial used to fit the samples. polyorder must be less than window_length.
Lambda: float
	smoothing parameter of the Whittaker filter described in Eilers (2003). The higher the smoother the fit.
d: int
	d parameter in Whittaker filter, see Eilers (2003).
ese_y: ndarray
	errors associated with y (for the gcvspline algorithms)</code></pre><p><strong>Outputs</strong></p><pre><code class="language-none">y_smo: ndarray
	smoothed signal sampled on x.</code></pre><p><strong>Note</strong></p><p>Use of GCVSmoothedNSpline, MSESmoothedNSpline, DOFSmoothedNSpline requires installation of gcvspline. See gcvspline documentation. See also documentation for details on GCVSmoothedNSpline, MSESmoothedNSpline, DOFSmoothedNSpline.</p><p>savgol uses the scipy.signal.savgol_filter() function.</p><p><strong>References</strong></p><p>Eilers, P.H.C., 2003. A Perfect Smoother. Anal. Chem. 75, 3631–3636. https://doi.org/10.1021/ac034173t</p><p>Scipy Cookbook: https://scipy-cookbook.readthedocs.io/items/SignalSmooth.html?highlight=smooth</p></div></div><a class="source-link" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/aa369ae314ee3b94b1fb11d1513243ef035d0da2/src/functions.jl#L403-L450">source</a></section><h2><a class="nav-anchor" id="Baseline-subtraction-1" href="#Baseline-subtraction-1">Baseline subtraction</a></h2><p>Baseline subtraction can be made with using the baseline function:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Spectra.baseline" href="#Spectra.baseline"><code>Spectra.baseline</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">baseline(x::Array{Float64},y::Array{Float64},roi::Array{Float64},basetype::AbstractString;polynomial_order=1, s = 1.0, lam = 10^5, p = 0.01, ratio = 0.01, niter = 10, p0_exp = [1.,1.,1.],p0_log =[1.,1.,1.])</code></pre><p>Allows subtracting a baseline under a x y spectrum; uses the baseline function from the rampy Python package.</p><p><strong>Parameters</strong></p><pre><code class="language-none">x_input : ndarray
	x values.
y_input : ndarray
	y values.
bir : ndarray
	Contain the regions of interest, organised per line.
	For instance, roi = np.array([[100., 200.],[500.,600.]]) will
	define roi between 100 and 200 as well as between 500 and 600.
	Note: This is NOT used by the &quot;als&quot; and &quot;arPLS&quot; algorithms, but still is a requirement when calling the function.
	bir and method probably will become args in a futur iteration of rampy to solve this.
methods : str
	&quot;poly&quot;: polynomial fitting, with splinesmooth the degree of the polynomial.
	&quot;unispline&quot;: spline with the UnivariateSpline function of Scipy, splinesmooth is
				 the spline smoothing factor (assume equal weight in the present case);
	&quot;gcvspline&quot;: spline with the gcvspl.f algorythm, really robust.
				 Spectra must have x, y, ese in it, and splinesmooth is the smoothing factor;
				 For gcvspline, if ese are not provided we assume ese = sqrt(y).
				 WARNING: Requires the installation of the gcvspline Python package prior to use in the Python ENV used by Julia.
				 See website for install instructions
	&quot;exp&quot;: exponential background;
	&quot;log&quot;: logarythmic background;
	&quot;rubberband&quot;: rubberband baseline fitting;
	&quot;als&quot;: automatic least square fitting following Eilers and Boelens 2005;
	&quot;arPLS&quot;: automatic baseline fit using the algorithm from Baek et al. 2015
			 Baseline correction using asymmetrically reweighted penalized least squares smoothing, Analyst 140: 250-257.</code></pre><p><strong>Options</strong></p><pre><code class="language-none">polynomial_order : Int
	The degree of the polynomial (0 for a constant), default = 1.
s : Float
	spline smoothing coefficient for the unispline and gcvspline algorithms.
lam : Float
	float, the lambda smoothness parameter for the ALS and ArPLS algorithms. Typical values are between 10**2 to 10**9, default = 10**5.
p : Float
	float, for the ALS algorithm, advised value between 0.001 to 0.1, default = 0.01.
ratio : float
	ratio parameter of the arPLS algorithm. default = 0.01.
niter : Int
	number of iteration of the ALS algorithm, default = 10.
p0_exp : List
	containg the starting parameter for the exp baseline fit with curve_fit. Default = [1.,1.,1.].
p0_log : List
	containg the starting parameter for the log baseline fit with curve_fit. Default = [1.,1.,1.,1.].</code></pre><p><strong>Returns</strong></p><pre><code class="language-none">out1 : ndarray
	Contain the corrected signal.
out2 : ndarray
	Contain the baseline.</code></pre><p><strong>Example</strong></p><p>Consider a Y signal sampled at X. We want to fit a polynomial baseline (2nd order) in the regions of interest comprised between x1 and x2, as well as x3 and x4.</p><pre><code class="language-none">```julia-repl
julia&gt; Y_corr, Y_baseline = baseline(X,Y,[x1 x2; x3 x4],&quot;poly&quot;,polynomial_order=2)
```</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/aa369ae314ee3b94b1fb11d1513243ef035d0da2/src/baseline.jl#L16-L84">source</a></section><h2><a class="nav-anchor" id="Frequency-shifts-correction-1" href="#Frequency-shifts-correction-1">Frequency shifts correction</a></h2><p>In case your spectra are shifted from a reference value, Spectra offers several functions that allows you to correct it from this shift.</p><p>To correct a spectrum from a shift of P wavenumbers, you can simply call:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Spectra.xshift_direct" href="#Spectra.xshift_direct"><code>Spectra.xshift_direct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">xshift_direct(original_x::Array{Float64}, original_y::Array{Float64}, p::Float64)</code></pre><p>To correct a spectrum for a p shift in X.</p><p>Used in xshift_correction.</p><p><strong>Inputs</strong></p><pre><code class="language-none">original_x: Array{Float64}
	x values
original_y: Array{Float64}
	y values associated with x
p: Array{Float64}
	value of how much x should be shifted</code></pre><p><strong>Outputs</strong></p><pre><code class="language-none">original_x: Array{Float64}
	same as input
corrected_y: Array{Float64}
	the y values corrected from the p shift in original_x
p: Array{Float64}
	same as input.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/aa369ae314ee3b94b1fb11d1513243ef035d0da2/src/functions.jl#L331-L358">source</a></section><p>Sometime, two signals from the same mineral show a shift in the X axis, while they share a common X axis. To correct from such thing, you can use the function:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Spectra.xshift_correction" href="#Spectra.xshift_correction"><code>Spectra.xshift_correction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">xshift_correction(full_x::Array{Float64}, full_shifted_y::Array{Float64}, ref_x::Array{Float64}, ref_y::Array{Float64},shifted_y::Array{Float64})</code></pre><p>To correct a shift between two spectra using a reference peak.</p><p><strong>Inputs</strong></p><pre><code class="language-none">full_x: Array{Float64}
	x values that are not good
full_shifted_y: Array{Float64}
	y values associated with full_x
ref_x: Array{Float64}
	x values that are good
ref_y: Array{Float64}
	y values associated with ref_x
shifted_y: Array{Float64}
	y values associated with a selected range of full_x that corresponds to ref_x (for instance, a specific peak that you want to use to correct the shift).</code></pre><p><strong>Outputs</strong></p><pre><code class="language-none">full_x: Array{Float64}
	same as input
corrected_y: Array{Float64}
	the full_shifted_y values corrected from the shift
p: Array{Float64}
	same as input.</code></pre><p>ref<em>x is the common X axis of two particular ref</em>y and shifted<em>y signals, that should be for instance an intense and well defined peak in your spectra. If ref</em>y and shifted_y do not share the same X axis, you can use first the Dierckx spline to re-sample one of them and have both sharing a common X axis. See the examples for further details.</p></div></div><a class="source-link" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/aa369ae314ee3b94b1fb11d1513243ef035d0da2/src/functions.jl#L365-L395">source</a></section><h2><a class="nav-anchor" id="array-manipulation-1" href="#array-manipulation-1">array manipulation</a></h2><p>For spectra recorded with decreasing frequencies, use the flipsp() function to put them back with increasing frequencies (necessary for some algo)</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Spectra.flipsp" href="#Spectra.flipsp"><code>Spectra.flipsp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">flipsp(spectra::Array{Float64})</code></pre><p>Flip an array along the row dimension (dim = 1) if the first column values are in decreasing order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/aa369ae314ee3b94b1fb11d1513243ef035d0da2/src/functions.jl#L456-L462">source</a></section><p>You can also resample a signal at wanted x_new values with resample()</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Spectra.resample" href="#Spectra.resample"><code>Spectra.resample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">resample(x::Array{Float64},y::Array{Float64},x_new::Array{Float64})</code></pre><p>Resample a y signal associated with x, along the x_new values.</p><p>Uses the Dierckx spline library.</p></div></div><a class="source-link" target="_blank" href="https://github.com/charlesll/Spectra.jl/blob/aa369ae314ee3b94b1fb11d1513243ef035d0da2/src/functions.jl#L470-L478">source</a></section><footer><hr/><a class="previous" href="PeakFitting.html"><span class="direction">Previous</span><span class="title">Peak fitting</span></a><a class="next" href="References.html"><span class="direction">Next</span><span class="title">References</span></a></footer></article></body></html>
